
#' ---
#' title: "Redlining"
#' output:
#'   pdf_document:
#'     keep_tex: true
#' ---
#'
#' This is a report generated by `knitr::spin()`
#'

#+ echo=FALSE

########
## Analysis for Redlining
########

require(rgdal)
require(rgeos)
require(sp)
require(sf)
require(stargazer)
library(viridis)
library(rvest)
require(tidycensus)
require(sp)
require(rgdal)
require(raster)
require(tigris)
require(snow)
require(doSNOW)
require(parallel)
require(foreach)
require(iterators)
options(tigris_use_cache = TRUE)
# numCores = 2
# 
# if(NROW(showConnections())!=numCores){ # faster core construction
#   if(NROW(showConnections())>0) stopCluster(cl)
#   cl <- parallel::makeCluster(rep('localhost',numCores), type='PSOCK')
#   registerDoSNOW(cl)}





#' # Introduction
#' This is the section with the introduction
#' 
#' # Data
#' This is the section with the data. 
#' And the section where we process the data




#+ process-1, echo=F, cache = T
# Load files --------------------------------------------------------------
WORK.OUT = file.path(BASE,'ajk41/Low Income Energy/Data/OUTPUT',Sys.Date())
dir.create(WORK.OUT, recursive=T)

Processed_HOLC = file.path(BASE, 'ajk41/Low Income Energy/Data/Zillow/Processed_HOLC')

# mykey = "ff90006e6d5f1960ef3bbb37579766bb563b1121"
# census_api_key(mykey, install=T)

BGZ = readRDS(jLoad(WORK.OUT, 'BG_ZCTA_HOLC_int'))
BG.int.full = BGZ[[1]]
ZCTA.int.full = BGZ[[2]]
HOLC = BGZ[[3]] # readRDS(jLoad(WORK.OUT, 'HOLC_with_data')) # 10-12


# Summarize (dissolve) BG and ZCTAs and average HOLC-data within.
#         - Hopefully a reasonable number of ~100% in A,B,C,or D.
BG.int = BG.int.full %>% 
  group_by_at(vars(AFFGEOID, TRACTCE, BLKGRPCE, UtilityGas:TotalRace)) %>%
  summarize(NBlack_YN = max(NBlack_YN), NBlack_PCT = weighted.mean(as.numeric(NBlack_PCT), w = segmentArea),
            Rent35_Mean = weighted.mean(Rent35_Mean, w=segmentArea), Rent3739_Mean = weighted.mean(Rent3739_Mean, w = segmentArea), 
            Minc = weighted.mean(Minc, w=segmentArea),
            GRADE.A = sum(segmentArea[GRADE=='A'])/sum(segmentArea),
            GRADE.B = sum(segmentArea[GRADE=='B'])/sum(segmentArea),
            GRADE.C = sum(segmentArea[GRADE=='C'])/sum(segmentArea),
            GRADE.D = sum(segmentArea[GRADE=='D'])/sum(segmentArea),
            GRADE.NA = sum(segmentArea[is.na(GRADE)])/sum(segmentArea),
            GRADE.max = factor(GRADE[which.max(segmentArea)]),
            share.max = max(segmentArea)/sum(segmentArea)) %>% # Note: check that no AFFGEOID are duplicated
  dplyr::mutate(STATEFP = gsub(pattern = '.*US([0-9]{2})([0-9]{3}).*', '\\1', x=AFFGEOID),
                COUNTYFP = gsub(pattern = '.*US([0-9]{2})([0-9]{3}).*', '\\2', x=AFFGEOID),
                STCO =     gsub(pattern = '.*US([0-9]{5}).*', '\\1', x=AFFGEOID)) %>%
  dplyr::mutate(isD = GRADE.D>.8,
                GRADE.max = relevel(GRADE.max, ref = 'C'))


ZCTA.int = ZCTA.int.full %>% 
  group_by_at(vars(AFFGEOID10, NAME.zip, UtilityGas:TotalRace)) %>%
  summarize(NBlack_YN = max(NBlack_YN), NBlack_PCT = weighted.mean(as.numeric(NBlack_PCT), w = segmentArea),
            Rent35_Mean = weighted.mean(Rent35_Mean, w=segmentArea), Rent3739_Mean = weighted.mean(Rent3739_Mean, w = segmentArea), 
            Minc = weighted.mean(Minc, w=segmentArea),
            GRADE.A = sum(segmentArea[GRADE=='A'])/sum(segmentArea),
            GRADE.B = sum(segmentArea[GRADE=='B'])/sum(segmentArea),
            GRADE.C = sum(segmentArea[GRADE=='C'])/sum(segmentArea),
            GRADE.D = sum(segmentArea[GRADE=='D'])/sum(segmentArea),
            GRADE.NA = sum(segmentArea[is.na(GRADE)])/sum(segmentArea),
            GRADE.max = factor(GRADE[which.max(segmentArea)], levels=c('C','D','B','A',NA)),
            share.max = max(segmentArea)/sum(segmentArea)) %>% # Note: check that no AFFGEOID are duplicated %>%
  st_join(counties(cb=TRUE) %>% dplyr::select(STCO = GEOID) %>% st_transform(st_crs(HOLC))) %>%
  dplyr::mutate(isD = GRADE.D>.8)

stopifnot(sum(duplicated(ZCTA.int$AFFGEOID10))==0)
stopifnot(sum(duplicated(BG.int$AFFGEOID))==0)


#' 
#' This is the text. $f = \frac{b}{c}$.
#' 

#+ echo=FALSE, fig.width=7
# New 10-13-20:
# Using shraes of each BG and ZCTA that are D/C/B/A
summary(lm(OtherSubstandard ~ poly(GRADE.D,2) + as.factor(STCO) + MedIncome2018 + Minc + Rent3739_Mean + NBlack_PCT, BG.int %>% dplyr::filter(!is.na(GRADE.D))))
summary(lm(OtherSubstandard ~ isD + as.factor(STCO) + MedIncome2018 + Minc + Rent3739_Mean + NBlack_PCT, BG.int %>% dplyr::filter(!is.na(GRADE.D))))
summary(lm(OtherSubstandard ~ as.factor(GRADE.max) + as.factor(STCO) + MedIncome2018*Minc + Rent3739_Mean, BG.int %>% dplyr::filter(share.max>.8)))
summary(lm(OtherSubstandard ~ as.factor(GRADE.max) + as.factor(STCO) + MedIncome2018+Minc + Rent3739_Mean + NBlack_YN + NBlack_PCT + Black + White + Asian, 
           data = BG.int %>% dplyr::filter(share.max>.9 & !is.na(GRADE.max))))



















knitr::knit_exit()
#' 
#' 
# rmarkdown::render(rstudioapi::getSourceEditorContext()$path)
###################
###################
###################

# Get Zillow --- skip below for Heartland ------------------------------------------

Z = foreach(z = iter(list.files(file.path(Processed_HOLC), pattern='.rds', full.names=T), by='cell'),
            .errorhandling = 'pass', .packages = c('dplyr','data.table','sf','rgdal','rgeos','sp','tidyverse'),
            .noexport = c('z'),
            .verbose=T) %dopar% {
             z = readRDS(z) %>% st_sf() 
             z = z[which(!is.na(st_coordinates(z)[,1] & !is.na(st_coordinates(z)[,2]))),]
             z = z %>% dplyr::select(-ImportParcelID, 
                                     -(PropertyHouseNumber:PropertyStreetPostDirectional), 
                                     -(PropertyAddressUnitDesignator:PropertyAddressUnitNumber),
                                     -PropertyBuildingNumber, -MailAddressMatchCode)  %>%
               dplyr::filter(!is.na(TotalRooms)) %>%
               st_join(HOLC %>% dplyr::select(polygon_id, map_id, NBlack_YN, NBlack_PCT, Rent35_Mean, Rent3739_Mean, Minc)) %>%
               dplyr::filter(!is.na(polygon_id) & !is.na(map_id))
            } # end dopar foreach

HhHOLC = do.call(rbind, Z) 
HhHOLC.small = HhHOLC %>% dplyr::filter(!is.na(Minc) & !is.na(NBlack_YN)) %>%
                dplyr::mutate(NoHeat = HeatingTypeorSystemStndCode=='NO', id = 1:n()) %>%
                st_join(., BG.int %>% dplyr::select(ST, GEOID, MedIncome1990, Pct.gas, Pct.electric, Pct.none))
                
HhHOLC.rsmall = HhHOLC.small %>% dplyr::filter(!is.na(GEOID))


Hh = HhHOLC.rsmall
lm1 = lm(NoHeat ~ GRADE + as.factor(paste0(map_id)), data=Hh)
lm2 = lm(NoHeat ~ GRADE + poly(Minc, 2) + as.factor(map_id), data=Hh)
lm3 = lm(NoHeat ~ GRADE + bs(Minc, 3)  + bs(MedIncome1990,3) + as.factor(map_id), data=HhHOLC.small)
lm4 = lm(NoHeat ~ GRADE + bs(Minc, 3)  + bs(MedIncome1990,3) + bs(NBlack_PCT, 3) + as.factor(map_id), data=HhHOLC.small)


samp = sample(NROW(HhHOLC), 500000, replace=F)





Hh = HhHOLC[!is.na(Minc) & !is.na(Rent35_Mean) & !is.na(NBlack_PCT),]
Hh = Hh[sample(.N, 500000, replace=F),]

lm1 = lm(NoHeat ~ GRADE + as.factor(paste0(map_id)), data=Hh)
lm2 = lm(NoHeat ~ GRADE + poly(Minc, 2) + as.factor(map_id), data=Hh)
lm3 = lm(NoHeat ~ GRADE + poly(Minc, 2) + poly(Rent35_Mean, 3) +  as.factor(map_id), data=Hh)
lm4 = lm(NoHeat ~ GRADE + poly(Minc, 2) + poly(Rent35_Mean, 3) + poly(NBlack_PCT, 3) + as.factor(map_id), data=Hh)

summary(lm1, robust=T)



res1 = robust.se(lm(NoHeat ~ GRADE + as.factor(map_id), data=Hh), Hh[,ST])
res2 = robust.se(lm(NoHeat ~ GRADE + poly(Minc, 2) + as.factor(paste0(map_id)), data=Hh), Hh[,ST])
res3 = robust.se(lm(Pct.none ~ GRADE + poly(Minc, 2) + poly(MedIncome1990, 2) +as.factor(paste0(map_id)), data=BGMC), BGMC$ST)[[2]]


# Census BG based analysis incl. Heartland  -------------------------------

BG.maj = BG.int %>% dplyr::filter(shareArea>.80) 

ggplot(BG.int %>% dplyr::filter(Maj==T &  STATEFP=='24'), aes(col=GRADE)) + geom_sf()

mapView(BG.int %>% dplyr::filter(Maj==T &  STATEFP=='24'), zcol='GRADE')
# saved as temp_2.RData #
# save.image("Z:/user/ajk41/Low Income Energy/Low Income Energy Rproj/temp_2.RData")
# load("Z:/user/ajk41/Low Income Energy/Low Income Energy Rproj/temp_2.RData")

## Pull and compile relevant household heating fuel data ##
# 2015 ACS:  DP04_0062E is all occupied Hh; DP04_0063...71E are counts by type
#            Where 63 is gas; 65 is electricity; 71 is no fuel.
#    Damnit, 2015 ACS doesn't do block group on any of the energy fields.
#    https://api.census.gov/data/2000/sf3/variables.html (navigate with this; add ".html" to anything JSON-like)

require(stargazer)
require(sandwich)
require(lmtest)
require(plm)


#--> Interpolate BG data over HOLC polygons
BG.maj.expanded = st_intersection(BG.maj, HOLC %>% dplyr::select(-GRADE, -STATEFP, -COUNTYFP)) %>% 
  mutate(INT_AREA = as.numeric(st_area(.)),
         SHARE    = INT_AREA/BG_AREA) %>% arrange(AFFGEOID)


insert.narm = F
BG.maj.collapsed = BG.maj.expanded %>% group_by(STATEFP, COUNTYFP, STCO, TRACTCE, BLKGRPCE, AFFGEOID, GRADE, city_id) %>%
  dplyr::summarize(UtilityGas = mean(UtilityGas, na.rm=insert.narm),
                   Electricity = mean(Electricity, na.rm=insert.narm),
                   OtherSubstandard = mean(OtherSubstandard, na.rm=insert.narm),
                   LPGas = mean(LPGas, na.rm=insert.narm),
                   FuelOil = mean(FuelOil, na.rm=insert.narm),
                   Solar = mean(Solar, na.rm=insert.narm),
                   #MedIncome1990 = mean(MedIncome1990, na.rm=insert.narm),
                   ID = paste(ID, collapse = ', '),
                   names = paste(name, collapse = ', '),
                   repair_class = paste(repair_class, collapse = ', '),
                   Rent35_Mean = sum(Rent35_Mean * (SHARE/sum(SHARE)), na.rm=insert.narm),
                   Rent3739_Mean = sum(Rent3739_Mean * (SHARE/sum(SHARE)), na.rm=insert.narm),
                   MedIncome2018 = sum(MedIncome2018*(SHARE/sum(SHARE)), na.rm=insert.narm),
                   NBlack_PCT = sum(as.numeric(NBlack_PCT)*(SHARE/sum(SHARE)), na.rm=insert.narm)) %>%
  dplyr::arrange(AFFGEOID) %>% ungroup()

BG.maj.collapsed = BG.maj.collapsed %>% mutate(GRADEf = factor(GRADE, levels=c('C','D','B','A')))


robust.se <- function(model, cluster){
  require(sandwich)
  require(lmtest)
  M <- length(unique(cluster))
  N <- length(cluster)
  K <- model$rank
  dfc <- (M/(M - 1)) * ((N - 1)/(N - K))
  uj <- apply(estfun(model), 2, function(x) tapply(x, cluster, sum));
  rcse.cov <- dfc * sandwich(model, meat = crossprod(uj)/N)
  rcse.se <- coeftest(model, rcse.cov)
  return(list(rcse.cov, rcse.se))
}

#Woodcoalker = LP, wood, coal, kerosene.

# http://www.drewdimmery.com/robust-ses-in-r/
# use:
BGMC = BG.maj.collapsed %>% dplyr::filter(!is.na(MedIncome2018) & !is.na(OtherSubstandard)) %>%
  dplyr::mutate(Pct.none = OtherSubstandard+FuelOil+LPGas)
res1 = robust.se(lm(OtherSubstandard ~ GRADEf + as.factor(city_id), data=BGMC), BGMC$STATEFP)[[2]]
res2 = robust.se(lm(OtherSubstandard ~ GRADEf + poly(MedIncome2018, 2) +as.factor(paste0(city_id)), data=BGMC), BGMC$STATEFP)[[2]]
res3 = robust.se(lm(OtherSubstandard ~ GRADEf + poly(MedIncome2018, 2)*as.factor(STATEFP) +as.factor(paste0(city_id)), data=BGMC), BGMC$STATEFP)[[2]]

stargazer(res1, res2, res3, dep.var.caption='Pct. substandard heating fuel', omit='city_id', omit.labels= c('City FE'), notes = 'Robust SE clustered by state')

# some ideas: just use wood+coal? justify no county fips FE? Need more rent data.


## Heartland
BGMC = BG.maj.collapsed %>% filter(!is.na(Minc) & !is.na(MedIncome1990) & !is.na(Pct.none) & Minc<30000) # there are some not-possible incomes in here.
res1 = robust.se(lm(Pct.none ~ GRADEf + as.factor(map_id), data=BGMC), BGMC$ST)[[2]]
res2 = robust.se(lm(Pct.none ~ GRADEf + poly(Minc, 2) +as.factor(paste0(map_id)), data=BGMC), BGMC$ST)[[2]]
res3 = robust.se(lm(Pct.none ~ GRADEf + poly(Minc, 2) + poly(MedIncome1990, 2) +as.factor(paste0(map_id)), data=BGMC), BGMC$ST)[[2]]

stargazer(res1, res2, res3, dep.var.caption='Pct. no heating fuel', omit='map_id', omit.labels= c('City FE'), notes = 'Robust SE clustered by state')



